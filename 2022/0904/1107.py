import sys
sys.stdin = open('1107.txt')

def find_near(n):
    global goodbtn
    finddif = []
    for i in goodbtn:
        if finddif == []:
            finddif.append(i)
        elif abs(finddif[-1]-n) > abs(i-n):
            finddif.pop(0)
            finddif.append(i)
        elif abs(finddif[-1]-n) == abs(i-n):
            finddif.append(i)

    return finddif

N = input() # 일단 문자열로 받아두자
# 초고교급 악력 소유자 수빈, 리모컨 버튼 너무 세게 눌러서 버튼 일부를 박살내버림
# 리모컨에는 버튼이 0~9까지 있고, +와 -가 있다.
# 채널이 무한대만큼 있는 어이없는 티비
# 수빈이가 이동하려 하는 채널은 N
# 어떤 버튼이 고장났는지 주어졌을 때, N으로 이동하기 위해 버튼을 최소 몇 번 눌러야 하는지 구해보자

# 간단함. 누를 수 있는 버튼만으로 만들 수 있는 숫자 중 N과 가장 가까운 수를 만들면 됨
# 지금 보고 있는 채널은 100번이라고 함
num_of_tofixbtn = int(input())
tofixbtn = list(map(int, input().split()))

# 생각해보자. 주어진 번호가 100과 가까우면, 그래서 새로 버튼을 눌러 다른 곳으로 이동한 후 + -로 조정하는 것 보다 그냥 바로 + - 로 조정하는게
# 더 효율적이라면? -> 그 범위는 어디부터 어디까지인가?
# 그냥 뭐든 일단 근처 수로 이동한 다음 + - 최소로 하는 방식으로 가고, 나중에 100에서 깡으로 + - 눌러서 이동하는 방식에 필요한 버튼 눌림의 횟수와
# 비교하여 더 효율적인 쪽을 선택하도록 하자

# N과 가까운 수를 만드는 방법에 대해 생각해보자.
# 1. N의 가장 높은 자릿수를 체크
# 멀쩡한 버튼을 하나의 리스트로 묶어 보관하자
goodbtn = [] # 멀쩡한 버튼 목록
for i in range(10):
    if i in tofixbtn:
        pass
    else:
        goodbtn.append(i)

# 50만 까지 -> 10**6 가짓수까지 가능함. 이거 다 돌려보고 판단해보면 시간 너무 오래 걸리지 않을까?
# 실제로 이 문제를 해결한다면? 만약 수 87987가 주어지고, 버튼 4 8 9가 고장났다고 하자
# 우선 가장 큰 단위의 수를 체크하겠지. 8인데, 8이 고장났네? 그럼 7이나 9를 해봐야겠지
# 가장 가까운 수를 판별하는 함수를 만들어보자(최대 2개의 값을 리턴하는 형식의)